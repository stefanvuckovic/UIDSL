/**
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainmodel.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.stefanvuckovic.domainmodel.DomainModelUtil;
import com.stefanvuckovic.domainmodel.domainModel.Attribute;
import com.stefanvuckovic.domainmodel.domainModel.AttributeType;
import com.stefanvuckovic.domainmodel.domainModel.BasicType;
import com.stefanvuckovic.domainmodel.domainModel.BoolConstant;
import com.stefanvuckovic.domainmodel.domainModel.BoolType;
import com.stefanvuckovic.domainmodel.domainModel.Cardinality;
import com.stefanvuckovic.domainmodel.domainModel.CardinalityType;
import com.stefanvuckovic.domainmodel.domainModel.CollectionType;
import com.stefanvuckovic.domainmodel.domainModel.Concept;
import com.stefanvuckovic.domainmodel.domainModel.Constant;
import com.stefanvuckovic.domainmodel.domainModel.DateConstant;
import com.stefanvuckovic.domainmodel.domainModel.DateType;
import com.stefanvuckovic.domainmodel.domainModel.DomainModelFactory;
import com.stefanvuckovic.domainmodel.domainModel.Entity;
import com.stefanvuckovic.domainmodel.domainModel.EntityDeleteOption;
import com.stefanvuckovic.domainmodel.domainModel.EnumLiteral;
import com.stefanvuckovic.domainmodel.domainModel.InheritanceMappingOption;
import com.stefanvuckovic.domainmodel.domainModel.InheritanceMappingType;
import com.stefanvuckovic.domainmodel.domainModel.IntConstant;
import com.stefanvuckovic.domainmodel.domainModel.IntType;
import com.stefanvuckovic.domainmodel.domainModel.LongConstant;
import com.stefanvuckovic.domainmodel.domainModel.LongType;
import com.stefanvuckovic.domainmodel.domainModel.Model;
import com.stefanvuckovic.domainmodel.domainModel.Null;
import com.stefanvuckovic.domainmodel.domainModel.PartOf;
import com.stefanvuckovic.domainmodel.domainModel.RefType;
import com.stefanvuckovic.domainmodel.domainModel.RelationshipOwner;
import com.stefanvuckovic.domainmodel.domainModel.SingleType;
import com.stefanvuckovic.domainmodel.domainModel.StaticFieldSelection;
import com.stefanvuckovic.domainmodel.domainModel.StringConstant;
import com.stefanvuckovic.domainmodel.domainModel.StringType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.StringExtensions;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class DomainModelGenerator extends AbstractGenerator {
  @Inject
  @Extension
  private DomainModelUtil _domainModelUtil;
  
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Model> _filter = Iterables.<Model>filter(_iterable, Model.class);
    final Model model = IterableExtensions.<Model>head(_filter);
    EList<Concept> _concepts = model.getConcepts();
    for (final Concept c : _concepts) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("domain/");
      String _name = c.getName();
      _builder.append(_name, "");
      _builder.append(".java");
      CharSequence _compile = this.compile(c);
      fsa.generateFile(_builder.toString(), _compile);
    }
  }
  
  public CharSequence compile(final Concept concept) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (concept instanceof Entity) {
      _matched=true;
      _switchResult = this.compile(((Entity)concept));
    }
    if (!_matched) {
      if (concept instanceof com.stefanvuckovic.domainmodel.domainModel.Enum) {
        _matched=true;
        _switchResult = this.compile(((com.stefanvuckovic.domainmodel.domainModel.Enum)concept), "domain");
      }
    }
    return _switchResult;
  }
  
  public CharSequence compile(final com.stefanvuckovic.domainmodel.domainModel.Enum en, final String packageName) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package ");
    _builder.append(packageName, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public enum ");
    String _name = en.getName();
    _builder.append(_name, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    EList<EnumLiteral> _literals = en.getLiterals();
    final Function1<EnumLiteral, CharSequence> _function = (EnumLiteral it) -> {
      return this.compile(it);
    };
    List<CharSequence> _map = ListExtensions.<EnumLiteral, CharSequence>map(_literals, _function);
    String _join = IterableExtensions.join(_map, ",\n");
    _builder.append(_join, "\t");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    {
      EList<Attribute> _attributes = en.getAttributes();
      boolean _isEmpty = _attributes.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("\t");
        _builder.append("private ");
        String _name_1 = en.getName();
        _builder.append(_name_1, "\t");
        _builder.append("(");
        EList<Attribute> _attributes_1 = en.getAttributes();
        final Function1<Attribute, String> _function_1 = (Attribute it) -> {
          return this.compileAttributeForEnumConstructor(it);
        };
        List<String> _map_1 = ListExtensions.<Attribute, String>map(_attributes_1, _function_1);
        String _join_1 = IterableExtensions.join(_map_1, ", ");
        _builder.append(_join_1, "\t");
        _builder.append(") {");
        _builder.newLineIfNotEmpty();
        {
          EList<Attribute> _attributes_2 = en.getAttributes();
          for(final Attribute attribute : _attributes_2) {
            _builder.append("\t");
            _builder.append("\t");
            CharSequence _compileAttributeAssignmentInEnumConstructor = this.compileAttributeAssignmentInEnumConstructor(attribute);
            _builder.append(_compileAttributeAssignmentInEnumConstructor, "\t\t");
            _builder.newLineIfNotEmpty();
          }
        }
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
      }
    }
    _builder.append("\t");
    _builder.newLine();
    {
      EList<Attribute> _attributes_3 = en.getAttributes();
      for(final Attribute attribute_1 : _attributes_3) {
        _builder.append("\t");
        _builder.append("private ");
        AttributeType _type = attribute_1.getType();
        String _compile = this.compile(_type);
        _builder.append(_compile, "\t");
        _builder.append(" ");
        String _name_2 = attribute_1.getName();
        _builder.append(_name_2, "\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.newLine();
    {
      EList<Attribute> _attributes_4 = en.getAttributes();
      for(final Attribute attribute_2 : _attributes_4) {
        _builder.append("\t");
        _builder.append("public ");
        AttributeType _type_1 = attribute_2.getType();
        String _compile_1 = this.compile(_type_1);
        _builder.append(_compile_1, "\t");
        _builder.append(" ");
        AttributeType _type_2 = attribute_2.getType();
        String _ter = this.getter(_type_2);
        _builder.append(_ter, "\t");
        String _name_3 = attribute_2.getName();
        String _firstUpper = StringExtensions.toFirstUpper(_name_3);
        _builder.append(_firstUpper, "\t");
        _builder.append("() {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("\t");
        _builder.append("return ");
        String _name_4 = attribute_2.getName();
        _builder.append(_name_4, "\t\t");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("}");
        _builder.newLine();
        _builder.append("\t");
        _builder.newLine();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence compileAttributeAssignmentInEnumConstructor(final Attribute attribute) {
    StringConcatenation _builder = new StringConcatenation();
    {
      AttributeType _type = attribute.getType();
      if ((_type instanceof DateType)) {
        _builder.append("if(");
        String _name = attribute.getName();
        _builder.append(_name, "");
        _builder.append(" != null) {");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("try {");
        _builder.newLine();
        _builder.append("\t\t");
        _builder.append("this.");
        String _name_1 = attribute.getName();
        _builder.append(_name_1, "\t\t");
        _builder.append(" = (new java.text.SimpleDateFormat(");
        _builder.append("\"", "\t\t");
        _builder.append("dd/MM/yyy");
        _builder.append("\"", "\t\t");
        _builder.append(")).parse(");
        String _name_2 = attribute.getName();
        _builder.append(_name_2, "\t\t");
        _builder.append(");");
        _builder.newLineIfNotEmpty();
        _builder.append("\t");
        _builder.append("} catch(Exception e) {}");
        _builder.newLine();
        _builder.append("}");
        _builder.newLine();
      } else {
        _builder.append("this.");
        String _name_3 = attribute.getName();
        _builder.append(_name_3, "");
        _builder.append(" = ");
        String _name_4 = attribute.getName();
        _builder.append(_name_4, "");
        _builder.append(";");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public CharSequence compile(final EnumLiteral literal) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = literal.getName();
    _builder.append(_name, "");
    {
      EList<Constant> _params = literal.getParams();
      boolean _isEmpty = _params.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        _builder.append("(");
      }
    }
    EList<Constant> _params_1 = literal.getParams();
    final Function1<Constant, Object> _function = (Constant it) -> {
      return this.compile(it);
    };
    List<Object> _map = ListExtensions.<Constant, Object>map(_params_1, _function);
    String _join = IterableExtensions.join(_map, ", ");
    _builder.append(_join, "");
    {
      EList<Constant> _params_2 = literal.getParams();
      boolean _isEmpty_1 = _params_2.isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        _builder.append(")");
      }
    }
    return _builder;
  }
  
  public String compileAttributeForEnumConstructor(final Attribute attr) {
    String _xblockexpression = null;
    {
      String type = null;
      AttributeType _type = attr.getType();
      if ((_type instanceof DateType)) {
        type = "String";
      } else {
        AttributeType _type_1 = attr.getType();
        String _compile = this.compile(_type_1);
        type = _compile;
      }
      String _name = attr.getName();
      _xblockexpression = ((type + " ") + _name);
    }
    return _xblockexpression;
  }
  
  public Object compile(final Constant const_) {
    Object _switchResult = null;
    boolean _matched = false;
    if (const_ instanceof IntConstant) {
      _matched=true;
      _switchResult = Integer.valueOf(((IntConstant)const_).getValue());
    }
    if (!_matched) {
      if (const_ instanceof LongConstant) {
        _matched=true;
        int _value = ((LongConstant)const_).getValue();
        _switchResult = (Integer.valueOf(_value) + "L");
      }
    }
    if (!_matched) {
      if (const_ instanceof StringConstant) {
        _matched=true;
        String _value = ((StringConstant)const_).getValue();
        String _plus = ("\"" + _value);
        _switchResult = (_plus + "\"");
      }
    }
    if (!_matched) {
      if (const_ instanceof DateConstant) {
        _matched=true;
        int _day = ((DateConstant)const_).getDay();
        String _plus = ("\"" + Integer.valueOf(_day));
        String _plus_1 = (_plus + "/");
        int _month = ((DateConstant)const_).getMonth();
        String _plus_2 = (_plus_1 + Integer.valueOf(_month));
        String _plus_3 = (_plus_2 + "/");
        int _year = ((DateConstant)const_).getYear();
        String _plus_4 = (_plus_3 + Integer.valueOf(_year));
        _switchResult = (_plus_4 + "\"");
      }
    }
    if (!_matched) {
      if (const_ instanceof BoolConstant) {
        _matched=true;
        _switchResult = ((BoolConstant)const_).getValue();
      }
    }
    if (!_matched) {
      if (const_ instanceof Null) {
        _matched=true;
        _switchResult = "null";
      }
    }
    return _switchResult;
  }
  
  public CharSequence compile(final Entity entity) {
    CharSequence _xblockexpression = null;
    {
      final ArrayList<Attribute> additionalAttrs = CollectionLiterals.<Attribute>newArrayList();
      Entity _superType = entity.getSuperType();
      boolean _equals = Objects.equal(_superType, null);
      if (_equals) {
        Attribute _idAttribute = this.getIdAttribute();
        additionalAttrs.add(_idAttribute);
      }
      final EntityDeleteOption deleteOption = this._domainModelUtil.deleteOption(entity);
      boolean _notEquals = (!Objects.equal(deleteOption, null));
      if (_notEquals) {
        Attribute _deleteAttribute = this.getDeleteAttribute();
        additionalAttrs.add(_deleteAttribute);
      }
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("package domain;");
      _builder.newLine();
      _builder.newLine();
      _builder.append("@javax.persistence.Entity");
      _builder.newLine();
      InheritanceMappingOption _inheritanceMapping = this._domainModelUtil.inheritanceMapping(entity);
      String _compile = this.compile(_inheritanceMapping);
      _builder.append(_compile, "");
      _builder.newLineIfNotEmpty();
      _builder.append("public class ");
      String _name = entity.getName();
      _builder.append(_name, "");
      _builder.append(" ");
      {
        Entity _superType_1 = entity.getSuperType();
        boolean _notEquals_1 = (!Objects.equal(_superType_1, null));
        if (_notEquals_1) {
          _builder.append("extends ");
          Entity _superType_2 = entity.getSuperType();
          String _name_1 = _superType_2.getName();
          _builder.append(_name_1, "");
          _builder.append(" ");
        }
      }
      _builder.append("{");
      _builder.newLineIfNotEmpty();
      {
        EList<Attribute> _attributes = entity.getAttributes();
        for(final Attribute attribute : _attributes) {
          _builder.append("\t");
          _builder.append("private ");
          AttributeType _type = attribute.getType();
          String _compile_1 = this.compile(_type);
          _builder.append(_compile_1, "\t");
          _builder.append(" ");
          String _name_2 = attribute.getName();
          _builder.append(_name_2, "\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
        }
      }
      {
        for(final Attribute attribute_1 : additionalAttrs) {
          _builder.append("\t");
          _builder.append("private ");
          AttributeType _type_1 = attribute_1.getType();
          String _compile_2 = this.compile(_type_1);
          _builder.append(_compile_2, "\t");
          _builder.append(" ");
          String _name_3 = attribute_1.getName();
          _builder.append(_name_3, "\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.newLine();
      {
        EList<Attribute> _attributes_1 = entity.getAttributes();
        for(final Attribute attribute_2 : _attributes_1) {
          _builder.append("\t");
          CharSequence _compileAttributeAnnotations = this.compileAttributeAnnotations(attribute_2);
          _builder.append(_compileAttributeAnnotations, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("public ");
          AttributeType _type_2 = attribute_2.getType();
          String _compile_3 = this.compile(_type_2);
          _builder.append(_compile_3, "\t");
          _builder.append(" ");
          AttributeType _type_3 = attribute_2.getType();
          String _ter = this.getter(_type_3);
          _builder.append(_ter, "\t");
          String _name_4 = attribute_2.getName();
          String _firstUpper = StringExtensions.toFirstUpper(_name_4);
          _builder.append(_firstUpper, "\t");
          _builder.append("() {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t");
          _builder.append("return ");
          String _name_5 = attribute_2.getName();
          _builder.append(_name_5, "\t\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
          _builder.append("\t");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("public void set");
          String _name_6 = attribute_2.getName();
          String _firstUpper_1 = StringExtensions.toFirstUpper(_name_6);
          _builder.append(_firstUpper_1, "\t");
          _builder.append("(");
          AttributeType _type_4 = attribute_2.getType();
          String _compile_4 = this.compile(_type_4);
          _builder.append(_compile_4, "\t");
          _builder.append(" ");
          String _name_7 = attribute_2.getName();
          _builder.append(_name_7, "\t");
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t");
          _builder.append("this.");
          String _name_8 = attribute_2.getName();
          _builder.append(_name_8, "\t\t");
          _builder.append(" = ");
          String _name_9 = attribute_2.getName();
          _builder.append(_name_9, "\t\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
          _builder.append("\t");
          _builder.newLine();
        }
      }
      {
        for(final Attribute attribute_3 : additionalAttrs) {
          _builder.append("\t");
          CharSequence _compileAttributeAnnotations_1 = this.compileAttributeAnnotations(attribute_3);
          _builder.append(_compileAttributeAnnotations_1, "\t");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("public ");
          AttributeType _type_5 = attribute_3.getType();
          String _compile_5 = this.compile(_type_5);
          _builder.append(_compile_5, "\t");
          _builder.append(" ");
          AttributeType _type_6 = attribute_3.getType();
          String _ter_1 = this.getter(_type_6);
          _builder.append(_ter_1, "\t");
          String _name_10 = attribute_3.getName();
          String _firstUpper_2 = StringExtensions.toFirstUpper(_name_10);
          _builder.append(_firstUpper_2, "\t");
          _builder.append("() {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t");
          _builder.append("return ");
          String _name_11 = attribute_3.getName();
          _builder.append(_name_11, "\t\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
          _builder.append("\t");
          _builder.newLine();
          _builder.append("\t");
          _builder.append("public void set");
          String _name_12 = attribute_3.getName();
          String _firstUpper_3 = StringExtensions.toFirstUpper(_name_12);
          _builder.append(_firstUpper_3, "\t");
          _builder.append("(");
          AttributeType _type_7 = attribute_3.getType();
          String _compile_6 = this.compile(_type_7);
          _builder.append(_compile_6, "\t");
          _builder.append(" ");
          String _name_13 = attribute_3.getName();
          _builder.append(_name_13, "\t");
          _builder.append(") {");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("\t");
          _builder.append("this.");
          String _name_14 = attribute_3.getName();
          _builder.append(_name_14, "\t\t");
          _builder.append(" = ");
          String _name_15 = attribute_3.getName();
          _builder.append(_name_15, "\t\t");
          _builder.append(";");
          _builder.newLineIfNotEmpty();
          _builder.append("\t");
          _builder.append("}");
          _builder.newLine();
          _builder.append("\t");
          _builder.newLine();
        }
      }
      _builder.append("}");
      _builder.newLine();
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }
  
  public CharSequence compileAttributeAnnotations(final Attribute attr) {
    StringConcatenation _builder = new StringConcatenation();
    {
      String _name = attr.getName();
      boolean _equals = _name.equals("id");
      if (_equals) {
        _builder.append("@javax.persistence.Id");
        _builder.newLine();
        _builder.append("@javax.persistence.GeneratedValue(strategy = javax.persistence.GenerationType.TABLE)");
        _builder.newLine();
      }
    }
    {
      AttributeType _type = attr.getType();
      com.stefanvuckovic.domainmodel.domainModel.Enum _attributeEnumRefTypeIfExists = this._domainModelUtil.getAttributeEnumRefTypeIfExists(_type);
      boolean _notEquals = (!Objects.equal(_attributeEnumRefTypeIfExists, null));
      if (_notEquals) {
        _builder.append("@javax.persistence.Enumerated(javax.persistence.EnumType.STRING)");
        _builder.newLine();
      }
    }
    {
      if ((this._domainModelUtil.collectionType(attr.getType()) && Objects.equal(this._domainModelUtil.getAttributeEntityRefTypeIfExists(((CollectionType) attr.getType()).getOfType()), null))) {
        _builder.append("@javax.persistence.ElementCollection");
        _builder.newLine();
      }
    }
    {
      AttributeType _type_1 = attr.getType();
      Entity _attributeEntityRefTypeIfExists = this._domainModelUtil.getAttributeEntityRefTypeIfExists(_type_1);
      boolean _notEquals_1 = (!Objects.equal(_attributeEntityRefTypeIfExists, null));
      if (_notEquals_1) {
        PartOf _partOfOption = this._domainModelUtil.partOfOption(attr);
        final boolean partOf = (!Objects.equal(_partOfOption, null));
        _builder.newLineIfNotEmpty();
        final RelationshipOwner relationshipOwner = this._domainModelUtil.relationshipOwner(attr);
        _builder.newLineIfNotEmpty();
        Cardinality _cardinality = this._domainModelUtil.cardinality(attr);
        AttributeType _type_2 = attr.getType();
        boolean _collectionType = this._domainModelUtil.collectionType(_type_2);
        String _annotationBasedOnCardinality = this.getAnnotationBasedOnCardinality(_cardinality, _collectionType);
        _builder.append(_annotationBasedOnCardinality, "");
        _builder.append("(");
        {
          if (partOf) {
            Cardinality _cardinality_1 = this._domainModelUtil.cardinality(attr);
            String _generatePartOf = this.generatePartOf(_cardinality_1);
            _builder.append(_generatePartOf, "");
          }
        }
        {
          if (partOf) {
            _builder.append(", ");
          }
        }
        {
          boolean _notEquals_2 = (!Objects.equal(relationshipOwner, null));
          if (_notEquals_2) {
            String _generateRelationshipOwner = this.generateRelationshipOwner(relationshipOwner);
            _builder.append(_generateRelationshipOwner, "");
          }
        }
        _builder.append(")");
        _builder.newLineIfNotEmpty();
      }
    }
    return _builder;
  }
  
  public String generateRelationshipOwner(final RelationshipOwner owner) {
    StaticFieldSelection _relationshipOwner = owner.getRelationshipOwner();
    Attribute _member = _relationshipOwner.getMember();
    String _name = _member.getName();
    String _plus = ("mappedBy = \"" + _name);
    return (_plus + "\"");
  }
  
  public String generatePartOf(final Cardinality card) {
    String _xifexpression = null;
    CardinalityType _card = card.getCard();
    boolean _equals = Objects.equal(_card, CardinalityType.ONE);
    if (_equals) {
      _xifexpression = ", orphanRemoval = true";
    } else {
      _xifexpression = "";
    }
    return ("cascade = javax.persistence.CascadeType.ALL" + _xifexpression);
  }
  
  public String getAnnotationBasedOnCardinality(final Cardinality card, final boolean isCollection) {
    String _xblockexpression = null;
    {
      String annotation = "@javax.persistence.";
      CardinalityType _card = card.getCard();
      if (_card != null) {
        switch (_card) {
          case ONE:
            String _annotation = annotation;
            annotation = (_annotation + "OneTo");
            break;
          case MANY:
            String _annotation_1 = annotation;
            annotation = (_annotation_1 + "ManyTo");
            break;
          default:
            break;
        }
      }
      String _xifexpression = null;
      if (isCollection) {
        _xifexpression = "Many";
      } else {
        _xifexpression = "One";
      }
      String _plus = (annotation + _xifexpression);
      _xblockexpression = annotation = _plus;
    }
    return _xblockexpression;
  }
  
  public Attribute getDeleteAttribute() {
    BoolType _createBoolType = DomainModelFactory.eINSTANCE.createBoolType();
    return this.createAndReturnAttributeWithBasicType("deleted", _createBoolType);
  }
  
  public Attribute getIdAttribute() {
    LongType _createLongType = DomainModelFactory.eINSTANCE.createLongType();
    return this.createAndReturnAttributeWithBasicType("id", _createLongType);
  }
  
  public Attribute createAndReturnAttributeWithBasicType(final String attrName, final BasicType type) {
    Attribute _xblockexpression = null;
    {
      final DomainModelFactory factory = DomainModelFactory.eINSTANCE;
      Attribute _createAttribute = factory.createAttribute();
      final Procedure1<Attribute> _function = (Attribute it) -> {
        it.setName(attrName);
      };
      final Attribute attr = ObjectExtensions.<Attribute>operator_doubleArrow(_createAttribute, _function);
      attr.setType(type);
      _xblockexpression = attr;
    }
    return _xblockexpression;
  }
  
  public String compile(final InheritanceMappingOption o) {
    boolean _equals = Objects.equal(o, null);
    if (_equals) {
      return "";
    } else {
      InheritanceMappingType _inheritanceMapping = o.getInheritanceMapping();
      String _type = _inheritanceMapping.getType();
      String _inheritanceTypeToString = this.inheritanceTypeToString(_type);
      String _plus = ("@javax.persistence.Inheritance(strategy = javax.persistence.InheritanceType." + _inheritanceTypeToString);
      return (_plus + ")");
    }
  }
  
  public String inheritanceTypeToString(final String type) {
    switch (type) {
      case "SINGLE_TABLE":
        return type;
      case "TABLE_PER_CONCRETE_CLASS":
        return "TABLE_PER_CLASS";
      case "TABLE_PER_CLASS":
        return "JOINED";
    }
    return null;
  }
  
  public String compile(final AttributeType type) {
    if ((type instanceof CollectionType)) {
      SingleType _ofType = ((CollectionType) type).getOfType();
      String _typeString = this.typeString(_ofType, false);
      String _plus = ("java.util.List<" + _typeString);
      return (_plus + ">");
    } else {
      if ((type instanceof SingleType)) {
        return this.typeString(((SingleType) type), true);
      }
    }
    return null;
  }
  
  public String getter(final AttributeType type) {
    String _xblockexpression = null;
    {
      if ((type instanceof BoolType)) {
        return "is";
      }
      _xblockexpression = "get";
    }
    return _xblockexpression;
  }
  
  protected String _typeString(final BasicType type, final boolean primitive) {
    boolean _matched = false;
    if (type instanceof StringType) {
      _matched=true;
      return "String";
    }
    if (!_matched) {
      if (type instanceof IntType) {
        _matched=true;
        if (primitive) {
          return "int";
        } else {
          return "Integer";
        }
      }
    }
    if (!_matched) {
      if (type instanceof LongType) {
        _matched=true;
        if (primitive) {
          return "long";
        } else {
          return "Long";
        }
      }
    }
    if (!_matched) {
      if (type instanceof BoolType) {
        _matched=true;
        if (primitive) {
          return "boolean";
        } else {
          return "Boolean";
        }
      }
    }
    if (!_matched) {
      if (type instanceof DateType) {
        _matched=true;
        return "java.util.Date";
      }
    }
    return null;
  }
  
  protected String _typeString(final RefType type, final boolean primitive) {
    Concept _reference = type.getReference();
    return _reference.getName();
  }
  
  public String typeString(final SingleType type, final boolean primitive) {
    if (type instanceof BasicType) {
      return _typeString((BasicType)type, primitive);
    } else if (type instanceof RefType) {
      return _typeString((RefType)type, primitive);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(type, primitive).toString());
    }
  }
}
