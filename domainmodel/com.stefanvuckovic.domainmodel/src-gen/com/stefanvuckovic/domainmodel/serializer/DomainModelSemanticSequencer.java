/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainmodel.serializer;

import com.google.inject.Inject;
import com.stefanvuckovic.domainmodel.domainModel.Attribute;
import com.stefanvuckovic.domainmodel.domainModel.BoolConstant;
import com.stefanvuckovic.domainmodel.domainModel.BoolType;
import com.stefanvuckovic.domainmodel.domainModel.Cardinality;
import com.stefanvuckovic.domainmodel.domainModel.CollectionType;
import com.stefanvuckovic.domainmodel.domainModel.DateConstant;
import com.stefanvuckovic.domainmodel.domainModel.DateType;
import com.stefanvuckovic.domainmodel.domainModel.DomainModelPackage;
import com.stefanvuckovic.domainmodel.domainModel.Entity;
import com.stefanvuckovic.domainmodel.domainModel.EntityDeleteOption;
import com.stefanvuckovic.domainmodel.domainModel.EnumLiteral;
import com.stefanvuckovic.domainmodel.domainModel.InheritanceMappingOption;
import com.stefanvuckovic.domainmodel.domainModel.InheritanceMappingType;
import com.stefanvuckovic.domainmodel.domainModel.IntConstant;
import com.stefanvuckovic.domainmodel.domainModel.IntType;
import com.stefanvuckovic.domainmodel.domainModel.LongConstant;
import com.stefanvuckovic.domainmodel.domainModel.LongType;
import com.stefanvuckovic.domainmodel.domainModel.Model;
import com.stefanvuckovic.domainmodel.domainModel.Null;
import com.stefanvuckovic.domainmodel.domainModel.PartOf;
import com.stefanvuckovic.domainmodel.domainModel.RefType;
import com.stefanvuckovic.domainmodel.domainModel.RelationshipOwner;
import com.stefanvuckovic.domainmodel.domainModel.Required;
import com.stefanvuckovic.domainmodel.domainModel.StaticFieldSelection;
import com.stefanvuckovic.domainmodel.domainModel.StringConstant;
import com.stefanvuckovic.domainmodel.domainModel.StringType;
import com.stefanvuckovic.domainmodel.services.DomainModelGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DomainModelSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DomainModelGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DomainModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DomainModelPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case DomainModelPackage.BOOL_CONSTANT:
				sequence_Constant(context, (BoolConstant) semanticObject); 
				return; 
			case DomainModelPackage.BOOL_TYPE:
				sequence_BasicType(context, (BoolType) semanticObject); 
				return; 
			case DomainModelPackage.CARDINALITY:
				sequence_AttributeOption(context, (Cardinality) semanticObject); 
				return; 
			case DomainModelPackage.COLLECTION_TYPE:
				sequence_CollectionType(context, (CollectionType) semanticObject); 
				return; 
			case DomainModelPackage.DATE_CONSTANT:
				sequence_Constant(context, (DateConstant) semanticObject); 
				return; 
			case DomainModelPackage.DATE_TYPE:
				sequence_BasicType(context, (DateType) semanticObject); 
				return; 
			case DomainModelPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DomainModelPackage.ENTITY_DELETE_OPTION:
				sequence_EntityOption(context, (EntityDeleteOption) semanticObject); 
				return; 
			case DomainModelPackage.ENUM:
				sequence_Enum(context, (com.stefanvuckovic.domainmodel.domainModel.Enum) semanticObject); 
				return; 
			case DomainModelPackage.ENUM_LITERAL:
				sequence_EnumLiteral(context, (EnumLiteral) semanticObject); 
				return; 
			case DomainModelPackage.INHERITANCE_MAPPING_OPTION:
				sequence_EntityOption(context, (InheritanceMappingOption) semanticObject); 
				return; 
			case DomainModelPackage.INHERITANCE_MAPPING_TYPE:
				sequence_InheritanceMappingType(context, (InheritanceMappingType) semanticObject); 
				return; 
			case DomainModelPackage.INT_CONSTANT:
				sequence_Constant(context, (IntConstant) semanticObject); 
				return; 
			case DomainModelPackage.INT_TYPE:
				sequence_BasicType(context, (IntType) semanticObject); 
				return; 
			case DomainModelPackage.LONG_CONSTANT:
				sequence_Constant(context, (LongConstant) semanticObject); 
				return; 
			case DomainModelPackage.LONG_TYPE:
				sequence_BasicType(context, (LongType) semanticObject); 
				return; 
			case DomainModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case DomainModelPackage.NULL:
				sequence_Constant(context, (Null) semanticObject); 
				return; 
			case DomainModelPackage.PART_OF:
				sequence_AttributeOption(context, (PartOf) semanticObject); 
				return; 
			case DomainModelPackage.REF_TYPE:
				sequence_RefType(context, (RefType) semanticObject); 
				return; 
			case DomainModelPackage.RELATIONSHIP_OWNER:
				sequence_AttributeOption(context, (RelationshipOwner) semanticObject); 
				return; 
			case DomainModelPackage.REQUIRED:
				sequence_AttributeOption(context, (Required) semanticObject); 
				return; 
			case DomainModelPackage.STATIC_FIELD_SELECTION:
				sequence_StaticFieldSelection(context, (StaticFieldSelection) semanticObject); 
				return; 
			case DomainModelPackage.STRING_CONSTANT:
				sequence_Constant(context, (StringConstant) semanticObject); 
				return; 
			case DomainModelPackage.STRING_TYPE:
				sequence_BasicType(context, (StringType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Option returns Cardinality
	 *     AttributeOption returns Cardinality
	 *
	 * Constraint:
	 *     card=CardinalityType
	 */
	protected void sequence_AttributeOption(ISerializationContext context, Cardinality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.CARDINALITY__CARD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.CARDINALITY__CARD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeOptionAccess().getCardCardinalityTypeEnumRuleCall_3_3_0(), semanticObject.getCard());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns PartOf
	 *     AttributeOption returns PartOf
	 *
	 * Constraint:
	 *     partOf?='partOf'
	 */
	protected void sequence_AttributeOption(ISerializationContext context, PartOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.PART_OF__PART_OF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.PART_OF__PART_OF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeOptionAccess().getPartOfPartOfKeyword_1_1_0(), semanticObject.isPartOf());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns RelationshipOwner
	 *     AttributeOption returns RelationshipOwner
	 *
	 * Constraint:
	 *     relationshipOwner=StaticFieldSelection
	 */
	protected void sequence_AttributeOption(ISerializationContext context, RelationshipOwner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.RELATIONSHIP_OWNER__RELATIONSHIP_OWNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.RELATIONSHIP_OWNER__RELATIONSHIP_OWNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeOptionAccess().getRelationshipOwnerStaticFieldSelectionParserRuleCall_2_3_0(), semanticObject.getRelationshipOwner());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns Required
	 *     AttributeOption returns Required
	 *
	 * Constraint:
	 *     required?='required'
	 */
	protected void sequence_AttributeOption(ISerializationContext context, Required semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.REQUIRED__REQUIRED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.REQUIRED__REQUIRED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeOptionAccess().getRequiredRequiredKeyword_0_1_0(), semanticObject.isRequired());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (type=AttributeType name=ID (options+=AttributeOption options+=AttributeOption*)?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns BoolType
	 *     SingleType returns BoolType
	 *     BasicType returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_BasicType(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns DateType
	 *     SingleType returns DateType
	 *     BasicType returns DateType
	 *
	 * Constraint:
	 *     {DateType}
	 */
	protected void sequence_BasicType(ISerializationContext context, DateType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns IntType
	 *     SingleType returns IntType
	 *     BasicType returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_BasicType(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns LongType
	 *     SingleType returns LongType
	 *     BasicType returns LongType
	 *
	 * Constraint:
	 *     {LongType}
	 */
	protected void sequence_BasicType(ISerializationContext context, LongType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns StringType
	 *     SingleType returns StringType
	 *     BasicType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_BasicType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns CollectionType
	 *     CollectionType returns CollectionType
	 *
	 * Constraint:
	 *     ofType=SingleType
	 */
	protected void sequence_CollectionType(ISerializationContext context, CollectionType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.COLLECTION_TYPE__OF_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.COLLECTION_TYPE__OF_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionTypeAccess().getOfTypeSingleTypeParserRuleCall_2_0(), semanticObject.getOfType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns BoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_Constant(ISerializationContext context, BoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns DateConstant
	 *
	 * Constraint:
	 *     (day=INT month=INT year=INT)
	 */
	protected void sequence_Constant(ISerializationContext context, DateConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__DAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__DAY));
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__MONTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__MONTH));
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__YEAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.DATE_CONSTANT__YEAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getDayINTTerminalRuleCall_4_1_0(), semanticObject.getDay());
		feeder.accept(grammarAccess.getConstantAccess().getMonthINTTerminalRuleCall_4_3_0(), semanticObject.getMonth());
		feeder.accept(grammarAccess.getConstantAccess().getYearINTTerminalRuleCall_4_5_0(), semanticObject.getYear());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns IntConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Constant(ISerializationContext context, IntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns LongConstant
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_Constant(ISerializationContext context, LongConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.LONG_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.LONG_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns Null
	 *
	 * Constraint:
	 *     {Null}
	 */
	protected void sequence_Constant(ISerializationContext context, Null semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constant returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Constant(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns EntityDeleteOption
	 *     EntityOption returns EntityDeleteOption
	 *
	 * Constraint:
	 *     deleteByFlag?='deleteByFlag'
	 */
	protected void sequence_EntityOption(ISerializationContext context, EntityDeleteOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.ENTITY_DELETE_OPTION__DELETE_BY_FLAG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.ENTITY_DELETE_OPTION__DELETE_BY_FLAG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityOptionAccess().getDeleteByFlagDeleteByFlagKeyword_0_1_0(), semanticObject.isDeleteByFlag());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns InheritanceMappingOption
	 *     EntityOption returns InheritanceMappingOption
	 *
	 * Constraint:
	 *     inheritanceMapping=InheritanceMappingType
	 */
	protected void sequence_EntityOption(ISerializationContext context, InheritanceMappingOption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.INHERITANCE_MAPPING_OPTION__INHERITANCE_MAPPING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.INHERITANCE_MAPPING_OPTION__INHERITANCE_MAPPING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEntityOptionAccess().getInheritanceMappingInheritanceMappingTypeParserRuleCall_1_3_0(), semanticObject.getInheritanceMapping());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Entity
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=ID superType=[Entity|ID]? (options+=EntityOption options+=EntityOption*)? attributes+=Attribute*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumLiteral returns EnumLiteral
	 *
	 * Constraint:
	 *     (name=ID (params+=Constant params+=Constant*)?)
	 */
	protected void sequence_EnumLiteral(ISerializationContext context, EnumLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Concept returns Enum
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (name=ID attributes+=Attribute* literals+=EnumLiteral+)
	 */
	protected void sequence_Enum(ISerializationContext context, com.stefanvuckovic.domainmodel.domainModel.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InheritanceMappingType returns InheritanceMappingType
	 *
	 * Constraint:
	 *     (type='SINGLE_TABLE' | type='TABLE_PER_CONCRETE_CLASS' | type='TABLE_PER_CLASS')
	 */
	protected void sequence_InheritanceMappingType(ISerializationContext context, InheritanceMappingType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     concepts+=Concept+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributeType returns RefType
	 *     SingleType returns RefType
	 *     RefType returns RefType
	 *
	 * Constraint:
	 *     reference=[Concept|ID]
	 */
	protected void sequence_RefType(ISerializationContext context, RefType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.REF_TYPE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.REF_TYPE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefTypeAccess().getReferenceConceptIDTerminalRuleCall_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StaticFieldSelection returns StaticFieldSelection
	 *
	 * Constraint:
	 *     (receiver=[Entity|ID] member=[Attribute|ID])
	 */
	protected void sequence_StaticFieldSelection(ISerializationContext context, StaticFieldSelection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.STATIC_FIELD_SELECTION__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.STATIC_FIELD_SELECTION__RECEIVER));
			if (transientValues.isValueTransient(semanticObject, DomainModelPackage.Literals.STATIC_FIELD_SELECTION__MEMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DomainModelPackage.Literals.STATIC_FIELD_SELECTION__MEMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStaticFieldSelectionAccess().getReceiverEntityIDTerminalRuleCall_0_0_1(), semanticObject.getReceiver());
		feeder.accept(grammarAccess.getStaticFieldSelectionAccess().getMemberAttributeIDTerminalRuleCall_2_0_1(), semanticObject.getMember());
		feeder.finish();
	}
	
	
}
