/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainmodel.validation

import com.stefanvuckovic.domainmodel.DomainModelUtil
import com.stefanvuckovic.domainmodel.domainModel.Attribute
import com.stefanvuckovic.domainmodel.domainModel.AttributeOption
import com.stefanvuckovic.domainmodel.domainModel.BasicType
import com.stefanvuckovic.domainmodel.domainModel.Cardinality
import com.stefanvuckovic.domainmodel.domainModel.CardinalityType
import com.stefanvuckovic.domainmodel.domainModel.Constant
import com.stefanvuckovic.domainmodel.domainModel.DomainModelPackage
import com.stefanvuckovic.domainmodel.domainModel.Entity
import com.stefanvuckovic.domainmodel.domainModel.EntityOption
import com.stefanvuckovic.domainmodel.domainModel.Enum
import com.stefanvuckovic.domainmodel.domainModel.EnumLiteral
import com.stefanvuckovic.domainmodel.domainModel.Model
import com.stefanvuckovic.domainmodel.domainModel.Option
import com.stefanvuckovic.domainmodel.domainModel.Required
import com.stefanvuckovic.domainmodel.domainModel.SingleType
import com.stefanvuckovic.domainmodel.scoping.CustomIndex
import com.stefanvuckovic.domainmodel.types.TypeComputing
import com.stefanvuckovic.domainmodel.types.TypeConformance
import javax.inject.Inject
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DomainModelValidator extends AbstractDomainModelValidator {
	
	@Inject extension DomainModelUtil
	@Inject extension TypeComputing
	@Inject extension TypeConformance
	@Inject extension CustomIndex
	
	public static val SEVERAL_OPTIONS_OF_SAME_TYPE = "You cannot specify more than one option of the same type"
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					DomainModelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkNoMoreThanOneOptionOfSameType(EntityOption opt) {
		val ent = opt.eContainer as Entity
		if(!ent.options.filter[isOptionOfSameType(opt)].empty) {
			error(SEVERAL_OPTIONS_OF_SAME_TYPE, null)
		}
	}
	
	@Check
	def checkNoMoreThanOneOptionOfSameType(AttributeOption opt) {
		val attr = opt.eContainer as Attribute
		if(!attr.options.filter[isOptionOfSameType(opt)].empty) {
			error(SEVERAL_OPTIONS_OF_SAME_TYPE, null)
		}
	}
	
	def isOptionOfSameType(Option opt1, Option opt2) {
		if(opt1.class.equals(opt2.class) && opt1 !== opt2) {
			return true
		}
		false
	}

//	@Check
//	def checkNoMoreThanOneOptionOfSameType(Entity e) {
//		val options = e.options
//		if(options != null) {
//			val map = HashMultimap.create()
//			for (var i = 0 ; i < options.length ; i++) {
//				val o = options.get(i)
//				if(o instanceof EntityDeleteOption) {
//					map.put(EntityDeleteOption, i)
//				} else if(o instanceof InheritanceMappingOption) {
//					map.put(InheritanceMappingOption, i)
//				}
//			}
//			fireErrorForDuplicateOptions(map, DomainModelPackage.Literals.ENTITY__OPTIONS)
//		}
//	}
	
//	@Check
//	def checkNoMoreThanOneOptionOfSameType(Attribute a) {
//		val options = a.options
//		if(options != null) {
//			val map = HashMultimap.create()
//			for (var i = 0 ; i < options.length ; i++) {
//				val o = options.get(i)
//				if(o instanceof Required) {
//					map.put(Required, i)
//				} else if(o instanceof PartOf) {
//					map.put(PartOf, i)
//				} else if(o instanceof RelationshipOwner) {
//					map.put(RelationshipOwner, i)
//				}
//			}
//			fireErrorForDuplicateOptions(map, DomainModelPackage.Literals.ATTRIBUTE__OPTIONS)
//		}
//	}
//	
//	def fireErrorForDuplicateOptions(HashMultimap<Class<? extends EObject>, Integer> map, EStructuralFeature feature) {
//		for(entry : map.asMap.entrySet) {
//				val duplicates = entry.value
//				if(duplicates.size > 1) {
//					for(i : duplicates) {
//						error(SEVERAL_OPTIONS_OF_SAME_TYPE, feature, i)
//					}
//				}
//			}
//	}
	
	@Check
	def checkEntityHierarchyCycles(Entity e) {
		if(e.hierarchyForEntity.contains(e)) {
			error("There is a cycle in entity hierarchy of entity '" + e.name + "'",
				DomainModelPackage.Literals.ENTITY__SUPER_TYPE)
		}
	}
	
	@Check
	def checkAttributeOptionsBasedOnContainer(AttributeOption opt) {
		if (opt.eContainer.eContainer instanceof Enum) {
			error("You can't specify options for enum attribute", null)
		}
	}
	
	@Check
	def checkIfRequiredOptionsArePresent(Attribute a) {
		val ent = a.type.attributeEntityRefTypeIfExists
		if(ent != null && a.cardinality == null) {
			error("You must specify cardinality for this attribute", null)
		}
	}
	
	@Check
	def checkAttributeOptionsBasedOnAttributeType(Attribute a) {
		if(a.type == null) {
			return;
		}
		val options = a.options
		if(options != null) {
			val refType = a.type.attributeEntityRefTypeIfExists != null
			val singleType = a.type instanceof SingleType
			
			for(var i = 0 ; i < options.length ; i++) {
				val o = options.get(i)
				if(o instanceof Required && !singleType || !(o instanceof Required) && !refType) {
					error("Specified option is not valid for this attribute", DomainModelPackage.Literals.ATTRIBUTE__OPTIONS, i)
				}
			}
		}
	}
	
	@Check 
	def void checkEnumTypes(Constant const) {
		val type = const.type
		val expectedType = const.expectedType
		if (expectedType == null || type == null)
			return;
		if (!type.isConformant(expectedType)) {
			error("Type not compatible. Expected '" + expectedType.typeToString + "' but was '" + type.typeToString + "'",
				null);
		}
	}
	
	@Check
	def void checkEnumAttributeType(Attribute attr) {
		val cont = attr.eContainer
		if(cont instanceof Enum) {
			if(!(attr.type instanceof BasicType)) {
				error("Attribute of type " + attr.type.typeToString + " is not allowed for Enum",
					null)
			}
		}
	}

	@Check 
	def void checkNumberOfEnumConstructorParameters(EnumLiteral literal) {
		val enum = literal.eContainer as Enum
		if (literal.params.size != enum.attributes.size) {
			error("Invalid number of arguments: expected " + enum.attributes.size + " but was " + literal.params.size,
				DomainModelPackage.eINSTANCE.enumLiteral_Name)
		}
	}
	
	@Check
	def void checkIfCardinalityCorrespondsToRelatedEntityMapping(Cardinality card) {
		val attr = card.eContainer as Attribute
		val relatedAttr = attr.getCorrespondingAttributeFromRelatedEntityIfExists 
		if(relatedAttr != null) {
			if(card.card == CardinalityType.ONE && relatedAttr.type.collectionType ||
				card.card == CardinalityType.MANY && relatedAttr.type.singleType) {
				error("Specified cardinality does not correspond to mapped attribute in related entity", null)
			}
		}
	}
	
	//only on file save because it is expensive opp
	@Check(CheckType.NORMAL)
	def checUniqueConceptNameInDifferentFiles(Model model) {
		val otherFilesConcepts = model.visibleConceptsDescriptionsFromOtherFiles
		for (c : model.concepts) {
			val conceptName = c.name
			if (otherFilesConcepts.containsKey(conceptName)) {
				error("Concept with name " + c.name + " is already defined",
					c, DomainModelPackage.eINSTANCE.concept_Name)
			}
		}
	}
	
}
