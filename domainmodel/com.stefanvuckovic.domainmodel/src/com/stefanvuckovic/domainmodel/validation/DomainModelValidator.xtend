/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainmodel.validation

import com.stefanvuckovic.domainmodel.DomainModelUtil
import com.stefanvuckovic.domainmodel.domainModel.Attribute
import com.stefanvuckovic.domainmodel.domainModel.AttributeOption
import com.stefanvuckovic.domainmodel.domainModel.BasicType
import com.stefanvuckovic.domainmodel.domainModel.Cardinality
import com.stefanvuckovic.domainmodel.domainModel.CardinalityType
import com.stefanvuckovic.domainmodel.domainModel.DomainModelPackage
import com.stefanvuckovic.domainmodel.domainModel.Entity
import com.stefanvuckovic.domainmodel.domainModel.EntityOption
import com.stefanvuckovic.domainmodel.domainModel.Enum
import com.stefanvuckovic.domainmodel.domainModel.EnumLiteral
import com.stefanvuckovic.domainmodel.domainModel.Expression
import com.stefanvuckovic.domainmodel.domainModel.Model
import com.stefanvuckovic.domainmodel.domainModel.Option
import com.stefanvuckovic.domainmodel.domainModel.Required
import com.stefanvuckovic.domainmodel.domainModel.SingleType
import com.stefanvuckovic.domainmodel.scoping.CustomIndex
import com.stefanvuckovic.domainmodel.types.TypeComputing
import com.stefanvuckovic.domainmodel.types.TypeConformance
import javax.inject.Inject
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.validation.CheckType
import com.stefanvuckovic.domainmodel.domainModel.StaticFieldSelection
import com.stefanvuckovic.domainmodel.LibraryConstants
import com.stefanvuckovic.domainmodel.domainModel.RefType
import com.stefanvuckovic.domainmodel.domainModel.AttributeType
import com.stefanvuckovic.domainmodel.domainModel.CollectionType
import com.stefanvuckovic.domainmodel.domainModel.RelationshipOwner

import static extension org.eclipse.xtext.EcoreUtil2.*
import com.stefanvuckovic.domainmodel.domainModel.Concept

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DomainModelValidator extends AbstractDomainModelValidator {
	
	@Inject extension DomainModelUtil
	@Inject extension TypeComputing
	@Inject extension TypeConformance
	@Inject extension CustomIndex
	
	public static val SEVERAL_OPTIONS_OF_SAME_TYPE = "You cannot specify more than one option of the same type"
//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					DomainModelPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}

	@Check
	def checkNoMoreThanOneOptionOfSameType(EntityOption opt) {
		val ent = opt.eContainer as Entity
		if(!ent.options.filter[isOptionOfSameType(opt)].empty) {
			error(SEVERAL_OPTIONS_OF_SAME_TYPE, null)
		}
	}
	
	@Check
	def checkNoMoreThanOneOptionOfSameType(AttributeOption opt) {
		val attr = opt.eContainer as Attribute
		if(!attr.options.filter[isOptionOfSameType(opt)].empty) {
			error(SEVERAL_OPTIONS_OF_SAME_TYPE, null)
		}
	}
	
	def isOptionOfSameType(Option opt1, Option opt2) {
		if(opt1.class.equals(opt2.class) && opt1 !== opt2) {
			return true
		}
		false
	}
	
	@Check
	def checkRelationshipOwnerOptions(AttributeOption opt) {
		val a = opt.eContainer as Attribute
		if(a.type instanceof SingleType && opt instanceof RelationshipOwner) {
			val owner = opt as RelationshipOwner
			val attr = owner.relationshipOwner?.member
			if(attr != null) {
				val card = a.cardinality
				if(card != null && card.card == CardinalityType.MANY) {
					val ownerType = attr.type
					if(ownerType instanceof CollectionType && (ownerType as CollectionType).ofType instanceof RefType &&
						((ownerType as CollectionType).ofType as RefType).reference === a.getContainerOfType(Concept)) {
							error("Many side must be relationship owner in many-to-one relationship", null)
						}
				}
			}
		}
	}
	
	@Check
	def checkDuplicateRelationshipOwnerOption(AttributeOption opt) {
		val a = opt.eContainer as Attribute
		if(opt instanceof RelationshipOwner) {
			val owner = opt as RelationshipOwner
			val attr = owner.relationshipOwner?.member
			if(attr != null) {
				val card = a.cardinality
				if(card != null) {
					var ownerSingleType = attr.type
					if(ownerSingleType instanceof CollectionType) {
						ownerSingleType = ownerSingleType.ofType
					}
					if(ownerSingleType instanceof RefType &&
						((ownerSingleType as RefType)).reference === a.getContainerOfType(Concept) &&
						attr.relationshipOwner != null) {
							error("Both ends of relationship can't be owners", null)
						}
				}
			}
		}
	}

//	@Check
//	def checkNoMoreThanOneOptionOfSameType(Entity e) {
//		val options = e.options
//		if(options != null) {
//			val map = HashMultimap.create()
//			for (var i = 0 ; i < options.length ; i++) {
//				val o = options.get(i)
//				if(o instanceof EntityDeleteOption) {
//					map.put(EntityDeleteOption, i)
//				} else if(o instanceof InheritanceMappingOption) {
//					map.put(InheritanceMappingOption, i)
//				}
//			}
//			fireErrorForDuplicateOptions(map, DomainModelPackage.Literals.ENTITY__OPTIONS)
//		}
//	}
	
//	@Check
//	def checkNoMoreThanOneOptionOfSameType(Attribute a) {
//		val options = a.options
//		if(options != null) {
//			val map = HashMultimap.create()
//			for (var i = 0 ; i < options.length ; i++) {
//				val o = options.get(i)
//				if(o instanceof Required) {
//					map.put(Required, i)
//				} else if(o instanceof PartOf) {
//					map.put(PartOf, i)
//				} else if(o instanceof RelationshipOwner) {
//					map.put(RelationshipOwner, i)
//				}
//			}
//			fireErrorForDuplicateOptions(map, DomainModelPackage.Literals.ATTRIBUTE__OPTIONS)
//		}
//	}
//	
//	def fireErrorForDuplicateOptions(HashMultimap<Class<? extends EObject>, Integer> map, EStructuralFeature feature) {
//		for(entry : map.asMap.entrySet) {
//				val duplicates = entry.value
//				if(duplicates.size > 1) {
//					for(i : duplicates) {
//						error(SEVERAL_OPTIONS_OF_SAME_TYPE, feature, i)
//					}
//				}
//			}
//	}
	
	@Check
	def checkEntityHierarchyCycles(Entity e) {
		if(e.hierarchyForEntity.contains(e)) {
			error("There is a cycle in entity hierarchy of entity '" + e.name + "'",
				DomainModelPackage.Literals.ENTITY__SUPER_TYPE)
		}
	}
	
	@Check
	def checkAttributeOptionsBasedOnContainer(AttributeOption opt) {
		if (opt.eContainer.eContainer instanceof Enum) {
			error("You can't specify options for enum attribute", null)
		}
	}
	
	@Check
	def checkIfRequiredOptionsArePresent(Attribute a) {
		val ent = a.type.attributeEntityRefTypeIfExists
		if(ent != null && a.cardinality == null) {
			error("You must specify cardinality for this attribute", null)
		}
	}
	
	@Check
	def checkConflictingAttributeOptions(AttributeOption o) {
		if(o instanceof Cardinality) {
			val card = o.card
			if(card == CardinalityType.MANY) {
				val isPartOf = (o.eContainer as Attribute).partOfOption != null
				if(isPartOf) {
					error("Cardinality 'MANY' is not valid for attribute with specified 'partOf' option", null)
				}
			}
		}
	}
	
	@Check
	def checkAttributeOptionsBasedOnAttributeType(Attribute a) {
		if(a.type == null) {
			return;
		}
		val options = a.options
		if(options != null) {
			val refType = a.type.attributeEntityRefTypeIfExists != null
			val singleType = a.type instanceof SingleType
			
			for(var i = 0 ; i < options.length ; i++) {
				val o = options.get(i)
				if(o instanceof Required && !singleType || !(o instanceof Required) && !refType) {
					error("Specified option is not valid for this attribute", DomainModelPackage.Literals.ATTRIBUTE__OPTIONS, i)
				}
			}
		}
	}
	
	@Check 
	def void checkEnumTypes(Expression const) {
		val type = const.type
		val expectedType = const.expectedType
		if (expectedType == null || type == null)
			return;
		if (!type.isConformant(expectedType)) {
			error("Type not compatible. Expected '" + expectedType.typeToString + "' but was '" + type.typeToString + "'",
				null);
		}
	}
	
	@Check
	def void checkEnumAttributeType(Attribute attr) {
		val cont = attr.eContainer
		if(cont instanceof Enum) {
			if(!(attr.type instanceof BasicType)) {
				error("Attribute of type " + attr.type.typeToString + " is not allowed for Enum",
					null)
			}
		}
	}

	@Check 
	def void checkNumberOfEnumConstructorParameters(EnumLiteral literal) {
		val enum = literal.eContainer as Enum
		if (literal.params.size != enum.attributes.size) {
			error("Invalid number of arguments: expected " + enum.attributes.size + " but was " + literal.params.size,
				DomainModelPackage.eINSTANCE.enumLiteral_Name)
		}
	}
	
	@Check
	def void checkIfCardinalityCorrespondsToRelatedEntityMapping(Cardinality card) {
		val attr = card.eContainer as Attribute
		val relatedAttr = attr.getCorrespondingAttributeFromRelatedEntityIfExists 
		if(relatedAttr != null) {
			if(card.card == CardinalityType.ONE && relatedAttr.type.collectionType ||
				card.card == CardinalityType.MANY && relatedAttr.type.singleType) {
				error("Specified cardinality does not correspond to mapped attribute in related entity", null)
			}
		}
	}
	
	//only on file save because it is expensive opp
	@Check(CheckType.NORMAL)
	def checUniqueConceptNameInDifferentFiles(Model model) {
		val otherFilesConcepts = model.visibleConceptsDescriptionsFromOtherFiles
		for (c : model.concepts) {
			val conceptName = c.name
			if (otherFilesConcepts.containsKey(conceptName)) {
				error("Concept with name " + c.name + " is already defined",
					c, DomainModelPackage.eINSTANCE.concept_Name)
			}
		}
	}
	
	@Check
	def checkReferenceToGeneralEntity(StaticFieldSelection sel) {
		val ent = sel.receiver
		if(ent.generalEntity) {
			error("General entity '" + LibraryConstants.COMMON_ENTITY_NAME + "' cannot be used in this context",
				DomainModelPackage.eINSTANCE.staticFieldSelection_Receiver
			)
		}
	}
	
	@Check
	def checkReferenceToGeneralEntity(AttributeType at) {
		var singleType = at
		if(at instanceof CollectionType) {
			singleType = at.ofType
		}
		if(singleType instanceof RefType && (singleType as RefType).reference instanceof Entity) {
			val ent = (singleType as RefType).reference as Entity
			if(ent.generalEntity) {
				error("General entity '" + LibraryConstants.COMMON_ENTITY_NAME + "' cannot be used in this context",
					null
				)
			}
		}
	}
	
	def isGeneralEntity(Entity ent) {
		if(ent != null && ent.name == LibraryConstants.COMMON_ENTITY_NAME) {
			return true
		}
		false
	}
	
}
