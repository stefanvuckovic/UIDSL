/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.uidsl.scoping

import com.stefanvuckovic.domainmodel.domainModel.DomainModelPackage
import com.stefanvuckovic.domainmodel.domainModel.Enum
import com.stefanvuckovic.domainmodel.domainModel.RefType
import com.stefanvuckovic.dto.DTOUtil
import com.stefanvuckovic.dto.dTO.DTOClass
import com.stefanvuckovic.dto.scoping.CustomIndex
import com.stefanvuckovic.uidsl.UIDSLUtil
import com.stefanvuckovic.uidsl.types.TypeComputing
import com.stefanvuckovic.uidsl.uIDSL.MemberSelectionExpression
import com.stefanvuckovic.uidsl.uIDSL.Method
import com.stefanvuckovic.uidsl.uIDSL.ServerComponent
import com.stefanvuckovic.uidsl.uIDSL.UIDSLPackage
import com.stefanvuckovic.uidsl.uIDSL.UIModel
import javax.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope

import static extension org.eclipse.emf.ecore.util.EcoreUtil.*

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class UIDSLScopeProvider extends AbstractUIDSLScopeProvider {
	
	@Inject extension CustomIndex
	@Inject extension TypeComputing
	@Inject extension DTOUtil
	@Inject extension UIDSLUtil
	
	val pack = UIDSLPackage.eINSTANCE
	
	override getScope(EObject context, EReference reference) {
		if(reference == DomainModelPackage.eINSTANCE.refType_Reference &&
			context.rootContainer instanceof UIModel) {
			return scopeForConcept(context)
		} else if(reference == pack.variableReference_Ref) {
			return scopeForVariableReference(context) 
		} else if(context instanceof MemberSelectionExpression) {
			return scopeForMemberSelectionExpression(context)
		} else {
			super.getScope(context, reference)
		}
	}
	
	override scopeForConcept(EObject context) {
		return new SimpleScope(context.listOfVisibleConceptsDescriptionsFromOtherFiles)
	}

	def scopeForVariableReference(EObject context) {
		val container = context.eContainer
		return switch (container) {
			Method:
				Scopes.scopeFor(container.params)
			default:
				//to be implemented when there are context in which variable can be declared
				IScope.NULLSCOPE
		}
	}

	def protected IScope scopeForMemberSelectionExpression(MemberSelectionExpression sel) {
		val type = sel.receiver.type

		if (type == null || !(type instanceof RefType)) {
			return IScope.NULLSCOPE
		}
		
		val concept = (type as RefType).reference
		switch(concept) {
			DTOClass:
				Scopes.scopeFor(concept.attributes, 
				Scopes.scopeFor(concept.attributesFromClassHierarchy))
			Enum:
				Scopes.scopeFor(concept.attributes)
			ServerComponent:
				if(sel.isIsMethod) {
					return Scopes.scopeFor(concept.methods + concept.fields)
				} else {
					return Scopes.scopeFor(concept.fields + concept.methods)
				}
		}
	}
	

}
