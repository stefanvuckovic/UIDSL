/**
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.dto.validation;

import com.google.common.base.Objects;
import com.stefanvuckovic.domainmodel.domainModel.Attribute;
import com.stefanvuckovic.domainmodel.domainModel.AttributeOption;
import com.stefanvuckovic.domainmodel.domainModel.AttributeType;
import com.stefanvuckovic.domainmodel.domainModel.CollectionType;
import com.stefanvuckovic.domainmodel.domainModel.Concept;
import com.stefanvuckovic.domainmodel.domainModel.DomainModelPackage;
import com.stefanvuckovic.domainmodel.domainModel.RefType;
import com.stefanvuckovic.dto.DTOUtil;
import com.stefanvuckovic.dto.dTO.DTOClass;
import com.stefanvuckovic.dto.dTO.DTOModel;
import com.stefanvuckovic.dto.dTO.IDAttribute;
import com.stefanvuckovic.dto.dTO.ObjectRepresentation;
import com.stefanvuckovic.dto.scoping.CustomIndex;
import com.stefanvuckovic.dto.validation.AbstractDTOValidator;
import java.util.Map;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.resource.IEObjectDescription;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DTOValidator extends AbstractDTOValidator {
  @Inject
  @Extension
  private CustomIndex _customIndex;
  
  @Inject
  @Extension
  private DTOUtil _dTOUtil;
  
  @Check(CheckType.NORMAL)
  public void checUniqueConceptNameInDifferentFiles(final DTOModel model) {
    final Map<String, IEObjectDescription> otherFilesConcepts = this._customIndex.getVisibleConceptsDescriptionsFromOtherFiles(model);
    EList<Concept> _concepts = model.getConcepts();
    for (final Concept c : _concepts) {
      {
        final String conceptName = c.getName();
        boolean _containsKey = otherFilesConcepts.containsKey(conceptName);
        if (_containsKey) {
          String _name = c.getName();
          String _plus = ("Concept with name " + _name);
          String _plus_1 = (_plus + " is already defined");
          EAttribute _concept_Name = DomainModelPackage.eINSTANCE.getConcept_Name();
          this.error(_plus_1, c, _concept_Name);
        }
      }
    }
  }
  
  @Check
  @Override
  public void checkAttributeOptionsBasedOnAttributeType(final Attribute a) {
    AttributeType _type = a.getType();
    boolean _equals = Objects.equal(_type, null);
    if (_equals) {
      return;
    }
    final EList<AttributeOption> options = a.getOptions();
    boolean _notEquals = (!Objects.equal(options, null));
    if (_notEquals) {
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(options, Object.class)).length); i++) {
        {
          final AttributeOption opt = options.get(i);
          if ((((((opt instanceof ObjectRepresentation) || (opt instanceof IDAttribute)) && 
            (a.getType() instanceof RefType)) && 
            (((RefType) a.getType()).getReference() instanceof DTOClass)) || 
            (a.getType() instanceof CollectionType))) {
            this.error("Specified option is not valid for this attribute", DomainModelPackage.Literals.ATTRIBUTE__OPTIONS, i);
          } else {
            if (((opt instanceof IDAttribute) && (a.getType() instanceof RefType))) {
              this.error("Specified option is not valid for this attribute", DomainModelPackage.Literals.ATTRIBUTE__OPTIONS, i);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkOnlyOneAttributeOptionPerClass(final AttributeOption opt) {
    EObject _eContainer = opt.eContainer();
    final Attribute attr = ((Attribute) _eContainer);
    EObject _eContainer_1 = attr.eContainer();
    if ((_eContainer_1 instanceof DTOClass)) {
      EObject _eContainer_2 = attr.eContainer();
      final DTOClass cl = ((DTOClass) _eContainer_2);
      final Class<? extends AttributeOption> optClass = opt.getClass();
      EList<Attribute> _attributes = cl.getAttributes();
      final Function1<Attribute, Boolean> _function = (Attribute a) -> {
        return Boolean.valueOf(this._dTOUtil.hasAttributeOption(a, optClass));
      };
      Iterable<Attribute> _filter = IterableExtensions.<Attribute>filter(_attributes, _function);
      int _size = IterableExtensions.size(_filter);
      boolean _greaterThan = (_size > 1);
      if (_greaterThan) {
        final boolean id = (opt instanceof IDAttribute);
        String _xifexpression = null;
        if (id) {
          _xifexpression = "id";
        } else {
          _xifexpression = "object representation";
        }
        String _plus = ("Only one attribute can be specified as " + _xifexpression);
        this.error(_plus, null);
      }
    }
  }
  
  @Check
  public void checkIfRequiredAttributeOptionExistsForDtoClass(final DTOClass cl) {
    Attribute _iDAttribute = this._dTOUtil.getIDAttribute(cl);
    boolean _equals = Objects.equal(_iDAttribute, null);
    if (_equals) {
      EAttribute _concept_Name = DomainModelPackage.eINSTANCE.getConcept_Name();
      this.error("Id attribute missing", _concept_Name);
    }
    Attribute _objectRepresentationAttribute = this._dTOUtil.getObjectRepresentationAttribute(cl);
    boolean _equals_1 = Objects.equal(_objectRepresentationAttribute, null);
    if (_equals_1) {
      EAttribute _concept_Name_1 = DomainModelPackage.eINSTANCE.getConcept_Name();
      this.error("Object representation attribute missing", _concept_Name_1);
    }
  }
}
