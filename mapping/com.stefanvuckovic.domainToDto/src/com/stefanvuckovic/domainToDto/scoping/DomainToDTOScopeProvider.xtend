/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainToDto.scoping

import com.stefanvuckovic.domainToDto.DomainToDTOUtil
import com.stefanvuckovic.domainToDto.domainToDTO.EntityMappingExpression
import com.stefanvuckovic.domainToDto.domainToDTO.MemberSelectionExpression
import com.stefanvuckovic.domainToDto.types.TypeComputing
import com.stefanvuckovic.domainmodel.DomainModelUtil
import com.stefanvuckovic.domainmodel.domainModel.Entity
import com.stefanvuckovic.domainmodel.domainModel.Enum
import com.stefanvuckovic.domainmodel.domainModel.RefType
import javax.inject.Inject
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import com.stefanvuckovic.domainToDto.domainToDTO.DomainToDTOPackage
import com.stefanvuckovic.domainmodel.domainModel.CollectionType
import com.stefanvuckovic.domainToDto.domainToDTO.Mapper
import com.stefanvuckovic.dto.DTOUtil

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DomainToDTOScopeProvider extends AbstractDomainToDTOScopeProvider {

	@Inject extension TypeComputing
	@Inject extension DomainModelUtil
	@Inject extension DomainToDTOUtil
	@Inject extension DTOUtil
	
	override getScope(EObject context, EReference reference) {
		if(context instanceof MemberSelectionExpression) {
			return scopeForMemberSelectionExpression(context)
		} else if(reference == DomainToDTOPackage.eINSTANCE.entityMappingExpression_Mapper) {
			return scopeForEntityMapper(context as EntityMappingExpression)
		} else if(reference == DomainToDTOPackage.eINSTANCE.mappedAttribute_Attr) {
			return scopeForDTOClassAttributes(context)
		} else {
			super.getScope(context, reference)
		}
	}
	
	def protected IScope scopeForMemberSelectionExpression(MemberSelectionExpression sel) {
		val receiver = sel.receiver
		if(receiver != null) {
			val type = receiver.type
	
			if (type == null || !(type instanceof RefType)) {
				return IScope.NULLSCOPE
			}
			
			val concept = (type as RefType).reference
			switch(concept) {
				Entity:
					Scopes.scopeFor(concept.attributes, 
					Scopes.scopeFor(concept.entityHierarchyAttributesWithCommonAttributesIncluded))
				Enum:
					Scopes.scopeFor(concept.attributes)
			}
		}
	}
	
	def protected IScope scopeForEntityMapper(EntityMappingExpression mappingExpression) {
		val mappedConcept = mappingExpression.mappedEntity
		if(mappedConcept != null) {
			val type = mappedConcept.type
			var singleType = type
			if(type instanceof CollectionType) {
				singleType = type.ofType
			}
			if(singleType != null && singleType instanceof RefType && (singleType as RefType).reference instanceof Entity) {
				val ent = (singleType as RefType).reference as Entity
				return Scopes.scopeFor(getMappersThatMapEntity(ent, mappingExpression))
			}
		}
	}
	
	def protected IScope scopeForDTOClassAttributes(EObject context) {
		var Mapper mapper = null
		if(context instanceof Mapper) {
			mapper = context as Mapper
		} else {
			mapper = context.eContainer as Mapper
		}
		val dto = mapper.dto
		if(dto != null) {
			val attrs = dto.attributesFromClassHierarchy
			return Scopes.scopeFor(dto.attributes + attrs)
		}
		return IScope.NULLSCOPE
	}
	
}
