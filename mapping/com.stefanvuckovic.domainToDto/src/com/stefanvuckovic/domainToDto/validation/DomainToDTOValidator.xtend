/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainToDto.validation

import com.stefanvuckovic.domainToDto.domainToDTO.DomainToDTOPackage
import com.stefanvuckovic.domainToDto.domainToDTO.EntityMappingExpression
import com.stefanvuckovic.domainToDto.domainToDTO.MappedAttribute
import com.stefanvuckovic.domainToDto.domainToDTO.MemberSelectionExpression
import com.stefanvuckovic.domainToDto.domainToDTO.StaticEntityRef
import com.stefanvuckovic.domainToDto.types.TypeComputing
import com.stefanvuckovic.domainToDto.types.TypeConformance
import com.stefanvuckovic.domainmodel.LibraryConstants
import com.stefanvuckovic.domainmodel.domainModel.CollectionType
import com.stefanvuckovic.domainmodel.domainModel.Entity
import com.stefanvuckovic.domainmodel.domainModel.Expression
import com.stefanvuckovic.domainmodel.domainModel.RefType
import com.stefanvuckovic.dto.DTOUtil
import javax.inject.Inject
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DomainToDTOValidator extends AbstractDomainToDTOValidator {
	
	@Inject extension TypeComputing
	@Inject extension TypeConformance
	@Inject extension DTOUtil
	//@Inject extension DomainToDTOUtil
	
	@Check
	def checkMappingExpressionType(MappedAttribute attr) {
		val exp = attr.mapping
		if(exp != null) {
			val msg = "Entity type not allowed inside mapping"
			if(exp instanceof StaticEntityRef) {
				error(msg, null)
			} else if(exp instanceof MemberSelectionExpression) {
				val member = exp.member
				if(member != null) {
					val type = member.type
					var singleType = type
					if(type instanceof CollectionType) {
						singleType = type.ofType
					}
					if(singleType != null && singleType instanceof RefType && (singleType as RefType).reference instanceof Entity) {
						error(msg, DomainToDTOPackage.eINSTANCE.mappedAttribute_Mapping)
					}
				}
			}
		}
	}
	
	@Check
	def checkEntityMappingExpression(EntityMappingExpression entMapping) {
		val exp = entMapping.mappedEntity
		if(exp != null) {
			val msg = "Only expression with Entity type allowed in this context"
			if(exp instanceof StaticEntityRef) {
				error(msg, null)
			} else if(exp instanceof MemberSelectionExpression) {
				val member = exp.member
				if(member != null) {
					val type = member.type
					var singleType = type
					if(type instanceof CollectionType) {
						singleType = type.ofType
					}
					if(singleType != null && !(singleType instanceof RefType && (singleType as RefType).reference instanceof Entity)) {
						error(msg, DomainToDTOPackage.eINSTANCE.entityMappingExpression_MappedEntity)
					}
				}
			}
		}
	}
	
	@Check
	def checkStaticEntityReference(StaticEntityRef r) {
		val ref = r.reference
		if(ref != null && ref.name == LibraryConstants.COMMON_ENTITY_NAME) {
			error("General entity '" + LibraryConstants.COMMON_ENTITY_NAME + "' cannot be used in this context", null)
		}
	}
	
	@Check 
	def void checkConformance(Expression e) {
		val type = e.type
		val expectedType = e.expectedType
		if (expectedType == null || type == null)
			return;
		if (!type.isConformant(expectedType)) {
			error("Incompatible types. Expected '" + expectedType.typeToString + "' but was '" + type.typeToString + "'",
				null);
		}
	}
	
//	@Check
//	def checkMapperHierarchyCycles(Mapper m) {
//		if(m.mapperHierarchy.contains(m)) {
//			error("There is a cycle in mapper hierarchy of mapper '" + m.name + "'",
//				DomainToDTOPackage.eINSTANCE.mapper_Name)
//		}
//	}
	
}