/*
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainToDto.generator

import com.stefanvuckovic.domainToDto.DomainToDTOUtil
import com.stefanvuckovic.domainToDto.domainToDTO.EntityMappingExpression
import com.stefanvuckovic.domainToDto.domainToDTO.MappedAttribute
import com.stefanvuckovic.domainToDto.domainToDTO.Mapper
import com.stefanvuckovic.domainToDto.domainToDTO.MappingModel
import com.stefanvuckovic.domainToDto.domainToDTO.MemberSelectionExpression
import com.stefanvuckovic.domainToDto.domainToDTO.StaticEntityRef
import com.stefanvuckovic.domainToDto.types.TypeComputing
import com.stefanvuckovic.domainmodel.domainModel.CollectionType
import com.stefanvuckovic.domainmodel.domainModel.Entity
import com.stefanvuckovic.domainmodel.domainModel.Expression
import com.stefanvuckovic.domainmodel.domainModel.RefType
import com.stefanvuckovic.domainmodel.generator.DomainModelGenerator
import com.stefanvuckovic.dto.generator.DTOGenerator
import java.util.List
import javax.inject.Inject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DomainToDTOGenerator extends AbstractGenerator {

	@Inject extension DomainToDTOUtil
	@Inject extension TypeComputing
	@Inject DTOGenerator dtoGenerator
	@Inject DomainModelGenerator dmGenerator
	
	val packageName = "mapping"
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.toIterable.filter(MappingModel).head
			for (m : model.mappers) {
				fsa.generateFile('''«packageName»/«m.name».java''', m.compileMapper)
			}
	}
	
	def compileMapper(Mapper m) {
		val variableNames = m.mappedEntitiesForMapper.map[e | e.name.toFirstLower].toList
		'''
			package «packageName»;
			
			@org.springframework.stereotype.Component
			public class «m.name» {
				«FOR usedMapper : m.usedMappers»
				@javax.inject.Inject
				private «usedMapper.name» «usedMapper.name.toFirstLower»;
				«ENDFOR»
				
				public dto.«m.dto.name» map(«m.mappedEntitiesForMapper.map[compileEntityParam].join(", ")») {
					«val uniqueDTOName = getUniqueFieldNameCurrentContext(variableNames, m.dto.name.toFirstLower)»
					«{variableNames.add(uniqueDTOName); ""}»
					dto.«m.dto.name» «uniqueDTOName» = new dto.«m.dto.name»();
					«FOR attr : m.attributes»
					«val ent = attr.mappedEntity»
					if(«ent.name.toFirstLower» != null) {
						«attr.compileAttribute(m, uniqueDTOName, variableNames)»
					}
					«ENDFOR»
					return «uniqueDTOName»;
				}
			}
		'''
	}
	
	def compileAttribute(MappedAttribute attr, Mapper m, String dtoVar, List<String> currentListOfVariableNames) {
		val exp = attr.mapping
		val nullChecks = newArrayList()
		if(exp instanceof EntityMappingExpression) {
			val mapped = exp.mappedEntity
			val type = mapped.type
			if(type instanceof RefType && (type as RefType).reference instanceof Entity) {
				val expr = mapped.compileExpression(nullChecks)
				nullChecks.reverse
				'''
					«IF !nullChecks.empty»
					if(«nullChecks.map[addNullCheck].join(" && ")») {
						«dtoVar».set«attr.attr.name.toFirstUpper»(this.«exp.mapper.name.toFirstLower».map(«expr»));
					}
					«ELSE»
					«dtoVar».set«attr.attr.name.toFirstUpper»(this.«exp.mapper.name.toFirstLower».map(«expr»));
					«ENDIF»
				'''
			} else if(type instanceof CollectionType) {
				val singleType = type.ofType
				val compiledExp = mapped.compileExpression(nullChecks)
				nullChecks.reverse
				nullChecks.add(compiledExp)
				'''
				if(«nullChecks.map[addNullCheck].join(" && ")») {
					«val uniqueAttrName = getUniqueFieldNameCurrentContext(currentListOfVariableNames, attr.attr.name)»
					«{currentListOfVariableNames.add(uniqueAttrName); ""}»
					«dtoGenerator.compileWithPackageIncluded(attr.attr.type)» «uniqueAttrName» = new java.util.ArrayList<>();
					«val compiledEntityType = dtoGenerator.compileWithPackageIncluded(singleType)»
					«val uniqueEntityVar = getUniqueFieldNameCurrentContext(currentListOfVariableNames, (singleType as RefType).varNameFromRefType)»
					«{currentListOfVariableNames.add(uniqueEntityVar); ""}»
					for(«compiledEntityType» «uniqueEntityVar» : «compiledExp») {
						«val compiledDTOType = dtoGenerator.compileWithPackageIncluded((attr.attr.type as CollectionType).ofType)»
						«val uniqueDTOVar = getUniqueFieldNameCurrentContext(currentListOfVariableNames, ((attr.attr.type as CollectionType).ofType as RefType).varNameFromRefType)»
						«{currentListOfVariableNames.add(uniqueDTOVar); ""}»
						«compiledDTOType» «uniqueDTOVar» = this.«exp.mapper.name.toFirstLower».map(«uniqueEntityVar»);
						if(«uniqueDTOVar» != null) {
							«uniqueAttrName».add(«uniqueDTOVar»);
						}
					}
					«dtoVar».set«attr.attr.name.toFirstUpper»(«uniqueAttrName»);
				}
				'''
			}
		} else {
			val expr = exp.compileExpression(nullChecks)
			nullChecks.reverse
			'''
				«IF !nullChecks.empty»
				if(«nullChecks.map[addNullCheck].join(" && ")») {
					«dtoVar».set«attr.attr.name.toFirstUpper»(«expr»);
				}
				«ELSE»
				«dtoVar».set«attr.attr.name.toFirstUpper»(«expr»);
				«ENDIF»	
			'''
				
		}
	}
	
	def addNullCheck(String s) {
		s + " != null"
	}
	
	def getVarNameFromRefType(RefType t) {
		t.reference.name.toFirstLower
	}
	
	def String compileExpression(Expression e, List<String> nullCheckExpressions) {
		switch (e) {
			StaticEntityRef: {
				val size = nullCheckExpressions.size
				for (var i = 0; i < size; i++) {
				    nullCheckExpressions.set(i, e.reference.name.toFirstLower + "." + nullCheckExpressions.get(i));
				}
				return e.reference.name.toFirstLower
			}
			MemberSelectionExpression: {
				val member = e.member
				val memberType = member.type
				val memberExpression = dmGenerator.getter(e.member.type) + e.member.name.toFirstUpper + "()" 
				val size = nullCheckExpressions.size
				for (var i = 0; i < size; i++) {
				    nullCheckExpressions.set(i, memberExpression + "." + nullCheckExpressions.get(i));
				}
				if(memberType instanceof RefType && (memberType as RefType).reference instanceof Entity) {
					nullCheckExpressions.add(memberExpression)
				}
				return e.receiver.compileExpression(nullCheckExpressions) + "." + memberExpression 
			}
			default:
				return ""
		}
	}
	
	def compileEntityParam(Entity e) {
		'''domain.«e.name» «e.name.toFirstLower»'''
	}
	
	def getUniqueFieldNameCurrentContext(Iterable<String> names, String name) {
		getUniqueFieldNameCurrentContext(names, name, 0)
	}
	
	def String getUniqueFieldNameCurrentContext(Iterable<String> names, String name, int counter) {
		var currName = if(counter == 0) name else name + counter
		for(n : names) {
			if(n == currName) {
				var newCounter = counter + 1
				return getUniqueFieldNameCurrentContext(names, name, newCounter)
			}
		}
		currName
	}
}
