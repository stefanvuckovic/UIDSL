/**
 * generated by Xtext 2.10.0
 */
package com.stefanvuckovic.domainToDto.validation;

import com.google.common.base.Objects;
import com.stefanvuckovic.domainToDto.domainToDTO.DomainToDTOPackage;
import com.stefanvuckovic.domainToDto.domainToDTO.EntityMappingExpression;
import com.stefanvuckovic.domainToDto.domainToDTO.MappedAttribute;
import com.stefanvuckovic.domainToDto.domainToDTO.MemberSelectionExpression;
import com.stefanvuckovic.domainToDto.domainToDTO.StaticEntityRef;
import com.stefanvuckovic.domainToDto.types.TypeComputing;
import com.stefanvuckovic.domainToDto.types.TypeConformance;
import com.stefanvuckovic.domainToDto.validation.AbstractDomainToDTOValidator;
import com.stefanvuckovic.domainmodel.LibraryConstants;
import com.stefanvuckovic.domainmodel.domainModel.Attribute;
import com.stefanvuckovic.domainmodel.domainModel.AttributeType;
import com.stefanvuckovic.domainmodel.domainModel.CollectionType;
import com.stefanvuckovic.domainmodel.domainModel.Entity;
import com.stefanvuckovic.domainmodel.domainModel.Expression;
import com.stefanvuckovic.domainmodel.domainModel.RefType;
import com.stefanvuckovic.domainmodel.domainModel.SingleType;
import com.stefanvuckovic.dto.DTOUtil;
import javax.inject.Inject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DomainToDTOValidator extends AbstractDomainToDTOValidator {
  @Inject
  @Extension
  private TypeComputing _typeComputing;
  
  @Inject
  @Extension
  private TypeConformance _typeConformance;
  
  @Inject
  @Extension
  private DTOUtil _dTOUtil;
  
  @Check
  public void checkMappingExpressionType(final MappedAttribute attr) {
    final Expression exp = attr.getMapping();
    boolean _notEquals = (!Objects.equal(exp, null));
    if (_notEquals) {
      final String msg = "Entity type not allowed inside mapping";
      if ((exp instanceof StaticEntityRef)) {
        this.error(msg, null);
      } else {
        if ((exp instanceof MemberSelectionExpression)) {
          final Attribute member = ((MemberSelectionExpression)exp).getMember();
          boolean _notEquals_1 = (!Objects.equal(member, null));
          if (_notEquals_1) {
            final AttributeType type = member.getType();
            AttributeType singleType = type;
            if ((type instanceof CollectionType)) {
              SingleType _ofType = ((CollectionType)type).getOfType();
              singleType = _ofType;
            }
            if ((((!Objects.equal(singleType, null)) && (singleType instanceof RefType)) && (((RefType) singleType).getReference() instanceof Entity))) {
              EReference _mappedAttribute_Mapping = DomainToDTOPackage.eINSTANCE.getMappedAttribute_Mapping();
              this.error(msg, _mappedAttribute_Mapping);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkEntityMappingExpression(final EntityMappingExpression entMapping) {
    final Expression exp = entMapping.getMappedEntity();
    boolean _notEquals = (!Objects.equal(exp, null));
    if (_notEquals) {
      final String msg = "Only expression with Entity type allowed in this context";
      if ((exp instanceof StaticEntityRef)) {
        this.error(msg, null);
      } else {
        if ((exp instanceof MemberSelectionExpression)) {
          final Attribute member = ((MemberSelectionExpression)exp).getMember();
          boolean _notEquals_1 = (!Objects.equal(member, null));
          if (_notEquals_1) {
            final AttributeType type = member.getType();
            AttributeType singleType = type;
            if ((type instanceof CollectionType)) {
              SingleType _ofType = ((CollectionType)type).getOfType();
              singleType = _ofType;
            }
            if (((!Objects.equal(singleType, null)) && (!((singleType instanceof RefType) && (((RefType) singleType).getReference() instanceof Entity))))) {
              EReference _entityMappingExpression_MappedEntity = DomainToDTOPackage.eINSTANCE.getEntityMappingExpression_MappedEntity();
              this.error(msg, _entityMappingExpression_MappedEntity);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkStaticEntityReference(final StaticEntityRef r) {
    final Entity ref = r.getReference();
    if (((!Objects.equal(ref, null)) && Objects.equal(ref.getName(), LibraryConstants.COMMON_ENTITY_NAME))) {
      this.error((("General entity \'" + LibraryConstants.COMMON_ENTITY_NAME) + "\' cannot be used in this context"), null);
    }
  }
  
  @Check
  public void checkConformance(final Expression e) {
    final AttributeType type = this._typeComputing.getType(e);
    final AttributeType expectedType = this._typeComputing.getExpectedType(e);
    if ((Objects.equal(expectedType, null) || Objects.equal(type, null))) {
      return;
    }
    boolean _isConformant = this._typeConformance.isConformant(type, expectedType);
    boolean _not = (!_isConformant);
    if (_not) {
      String _typeToString = this._dTOUtil.typeToString(expectedType);
      String _plus = ("Incompatible types. Expected \'" + _typeToString);
      String _plus_1 = (_plus + "\' but was \'");
      String _typeToString_1 = this._dTOUtil.typeToString(type);
      String _plus_2 = (_plus_1 + _typeToString_1);
      String _plus_3 = (_plus_2 + "\'");
      this.error(_plus_3, 
        null);
    }
  }
}
